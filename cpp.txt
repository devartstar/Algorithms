{
  // Place your snippets for cpp here. Each snippet is defined under a snippet name and has a prefix, body and
  // description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
  // $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the
  // same ids are connected.
  // Example:
  // "Print to console": {
  // 	"prefix": "log",
  // 	"body": [
  // 		"console.log('$1');",
  // 		"$2"
  // 	],
  // 	"description": "Log output to console"
  // }
  "File header": {
    "prefix": "header",
    "body": [
      "name: Devjit Choudhury",
      "title: ${title:Enter title}",
      "date: ${date:Insert datetime}"
    ]
  },
  "Basic CP template": {
    "prefix": "basic",
    "body": [
      "/*",
      "	-------------------------------------",
      "	|									|",
      "	|	Author - Devjit Choudhury		|",
      "	|	Date   - ___________________ 	|",
      "	|    	                            |",
      "	-------------------------------------",
      "",
      "	Link - ",
      "*/",
      "",
      "#include <bits/stdc++.h>",
      "#include<ext/pb_ds/assoc_container.hpp>",
      "#include<ext/pb_ds/tree_policy.hpp>",
      "",
      "using namespace std;",
      "using namespace __gnu_pbds;",
      "",
      "#define ar array",
      "#define ll long long",
      "#define ull unsigned long long",
      "#define lld long double",
      "#define vi vector<int>",
      "#define pii pair<int,int>",
      "#define pll pair<long long, long long>",
      "#define vll vector<long long>",
      "#define vpii vector<pair<int,int>>",
      "#define vpll vector<pair<long long, long long>>",
      "#define vb vector<bool>",
      "#define all(v) v.begin(),v.end()",
      "#define f0(i, n) for (int i = 0; i < n; i++) // 0 based indexing",
      "#define f0r(i, n) for (int i = n-1; i >= 0; i--)",
      "#define f1(i, n) for (int i = 1; i <= n; i++) // 1 based indexing",
      "#define f1r(i, n) for (int i = n; i >= 1; i--)",
      "#define f(i, a, b) for (int i = a; i <= b; i++) // 1 based indexing",
      "#define fr(i, a, b) for (int i = a; i >= b; i--)",
      "#define fll0(i, n) for (long long i = 0; i < n; i++) // 0 based indexing",
      "#define fll1(i, n) for (long long i = 1; i <= n; i++) // 1 based indexing",
      "#define fll(i, a, b) for (long long i = a; i <= b; i++) // 1 based indexing",
      "#define disp(v) for(auto x : v) cout<<x<<\" \"; cout<<endl;",
      "#define disp0(v, n) for(int i = 0; i < n; i++) cout<<v[i]<<\" \"; cout<<endl;",
      "#define disp0r(v, n) for(int i = n-1; i >= 0; i--) cout<<v[i]<<\" \"; cout<<endl;",
      "#define disp1(v, n) for(int i = 1; i <= n; i++) cout<<v[i]<<\" \"; cout<<endl;",
      "#define disp1r(v, n) for(int i = n; i >= 1; i--) cout<<v[i]<<\" \"; cout<<endl;",
      "#define pb push_back",
      "#define ff first",
      "#define ss second",
      "#define mp make_pair",
      "#define sz(v) (int)v.size()",
      "#define len(v) (int)v.length()",
      "",
      "#ifndef ONLINE_JUDGE",
      "#define debug(x) cerr << #x <<\" \"; _print(x); cerr << endl;",
      "#else",
      "#define debug(x)",
      "#endif",
      "",
      "void _print(ll w) {cerr << w;}",
      "void _print(int w) {cerr << w;}",
      "void _print(string w) {cerr << w;}",
      "void _print(char w) {cerr << w;}",
      "void _print(lld w) {cerr << w;}",
      "void _print(double w) {cerr << w;}",
      "void _print(ull w) {cerr << w;}",
      "",
      "template <class T, class V> void _print(pair <T, V> p);",
      "template <class T> void _print(vector <T> v);",
      "template <class T> void _print(set <T> v);",
      "template <class T, class V> void _print(map <T, V> v);",
      "template <class T> void _print(multiset <T> v);",
      "template <class T, class V> void _print(pair <T, V> p) {cerr << \"{\"; _print(p.ff); cerr << \",\"; _print(p.ss); cerr << \"}\";}",
      "template <class T> void _print(vector <T> v) {cerr << \"[ \"; for (T i : v) {_print(i); cerr << \" \";} cerr << \"]\";}",
      "template <class T> void _print(set <T> v) {cerr << \"[ \"; for (T i : v) {_print(i); cerr << \" \";} cerr << \"]\";}",
      "template <class T> void _print(multiset <T> v) {cerr << \"[ \"; for (T i : v) {_print(i); cerr << \" \";} cerr << \"]\";}",
      "template <class T, class V> void _print(map <T, V> v) {cerr << \"[ \"; for (auto i : v) {_print(i); cerr << \" \";} cerr << \"]\";}",
      "",
      "typedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> pbds; // find_by_order, order_of_key",
      "",
      "const int MAX_N = 1e5 + 1;",
      "const ll MOD = 1e9 + 7;",
      "const ll INF = 1e9;",
      "",
      "",
      "void solve() {",
      "\t$2",
      "}",
      "",
      "int main() {",
      "	ios_base::sync_with_stdio(0);",
      "	cin.tie(0); cout.tie(0);",
      "	#ifndef ONLINE_JUDGE",
      "	  freopen(\"input.txt\",\"r\",stdin);",
      "	  freopen(\"output.txt\",\"w\",stdout);",
      "	  freopen(\"error.txt\", \"w\", stderr);",
      "	#endif",
      "	int tc = 1;",
      "	//$1cin >> tc;",
      "	f1(t,tc) {",
      "		// cout << \"Case #\" << t  << \": \";",
      "		solve();",
      "	}",
      "}",
      ""
    ],
    "description": "Basic CP template"
  },
  "My Graph CP Template": {
    "prefix": "graph",
    "body": [
      "/*",
      "    -------------------------------------",
      "    |									|",
      "    |	Author - Devjit Choudhury		|",
      "    |	Date   - ___________________ 	|	",
      "    |    	                            |",
      "    -------------------------------------",
      "",
      "    Link - ",
      "*/",
      "",
      "#include <bits/stdc++.h>",
      "using namespace std;",
      "",
      "#define ar array",
      "#define ll long long",
      "#define ull unsigned long long",
      "#define lld long double",
      "#define vi vector<int>",
      "#define pii pair<int,int>",
      "#define pll pair<long, long>",
      "#define vll vector<long long>",
      "#define vpii vector<pair<int,int>>",
      "#define all(v) v.begin(),v.end()",
      "#define f0(i, n) for (int i = 0; i < n; i++) // 0 based indexing",
      "#define f1(i, n) for (int i = 1; i <= n; i++) // 1 based indexing",
      "#define f(i, a, b) for (int i = a; i <= b; i++) // 1 based indexing",
      "#define fll0(i, n) for (long long i = 0; i < n; i++) // 0 based indexing",
      "#define fll1(i, n) for (long long i = 1; i <= n; i++) // 1 based indexing",
      "#define fll(i, a, b) for (long long i = a; i <= b; i++) // 1 based indexing",
      "#define pb push_back",
      "#define ff first",
      "#define ss second",
      "#define mp make_pair",
      "",
      "#ifndef ONLINE_JUDGE",
      "#define debug(x) cerr << #x <<\" \"; _print(x); cerr << endl;",
      "#else",
      "#define debug(x)",
      "#endif",
      "",
      "void _print(ll w) {cerr << w;}",
      "void _print(int w) {cerr << w;}",
      "void _print(string w) {cerr << w;}",
      "void _print(char w) {cerr << w;}",
      "void _print(lld w) {cerr << w;}",
      "void _print(double w) {cerr << w;}",
      "void _print(ull w) {cerr << w;}",
      "",
      "template <class T, class V> void _print(pair <T, V> p);",
      "template <class T> void _print(vector <T> v);",
      "template <class T> void _print(set <T> v);",
      "template <class T, class V> void _print(map <T, V> v);",
      "template <class T> void _print(multiset <T> v);",
      "template <class T, class V> void _print(pair <T, V> p) {cerr << \"{\"; _print(p.ff); cerr << \",\"; _print(p.ss); cerr << \"}\";}",
      "template <class T> void _print(vector <T> v) {cerr << \"[ \"; for (T i : v) {_print(i); cerr << \" \";} cerr << \"]\";}",
      "template <class T> void _print(set <T> v) {cerr << \"[ \"; for (T i : v) {_print(i); cerr << \" \";} cerr << \"]\";}",
      "template <class T> void _print(multiset <T> v) {cerr << \"[ \"; for (T i : v) {_print(i); cerr << \" \";} cerr << \"]\";}",
      "template <class T, class V> void _print(map <T, V> v) {cerr << \"[ \"; for (auto i : v) {_print(i); cerr << \" \";} cerr << \"]\";}",
      "",
      "const int MAX_N = 1e5 + 1;",
      "const ll MOD = 1e9 + 7;",
      "const ll INF = 1e9;",
      "",
      "int n,m;",
      "vi v[100001];",
      "int visited[100001];",
      "",
      "void solve(){",
      "    ",
      "}",
      "",
      "void makeGraph(){",
      "\t$2 ",
      "}",
      "",
      "int main() {",
      "    ios_base::sync_with_stdio(0);",
      "    cin.tie(0); cout.tie(0);",
      "    #ifndef ONLINE_JUDGE",
      "      freopen(\"input.txt\",\"r\",stdin);",
      "      freopen(\"output.txt\",\"w\",stdout);",
      "      freopen(\"error.txt\", \"w\", stderr);",
      "    #endif",
      "    int tc = 1;",
      "       //$1cin >> tc;",
      "    ",
      "    f1(t,tc) {",
      "        // cout << \"Case #\" << t  << \": \";",
      "        f1(i,n){",
      "            v[i].clear();",
      "            visited[i]=0;",
      "        }",
      "        makeGraph();",
      "        solve();",
      "    }",
      "}"
    ],
    "description": "My Graph CP Template"
  },
  "My Graph-DFS CP Template": {
    "prefix": "graph_dfs",
    "body": [
      "/*",
      "    -------------------------------------",
      "    |									|",
      "    |	Author - Devjit Choudhury		|",
      "    |	Date   - ___________________ 	|	",
      "    |    	                            |",
      "    -------------------------------------",
      "",
      "    Link - ",
      "*/",
      "",
      "#include <bits/stdc++.h>",
      "using namespace std;",
      "",
      "#define ar array",
      "#define ll long long",
      "#define ull unsigned long long",
      "#define lld long double",
      "#define vi vector<int>",
      "#define pii pair<int,int>",
      "#define pll pair<long, long>",
      "#define vll vector<long long>",
      "#define vpii vector<pair<int,int>>",
      "#define all(v) v.begin(),v.end()",
      "#define f0(i, n) for (int i = 0; i < n; i++) // 0 based indexing",
      "#define f1(i, n) for (int i = 1; i <= n; i++) // 1 based indexing",
      "#define f(i, a, b) for (int i = a; i <= b; i++) // 1 based indexing",
      "#define fll0(i, n) for (long long i = 0; i < n; i++) // 0 based indexing",
      "#define fll1(i, n) for (long long i = 1; i <= n; i++) // 1 based indexing",
      "#define fll(i, a, b) for (long long i = a; i <= b; i++) // 1 based indexing",
      "#define pb push_back",
      "#define ff first",
      "#define ss second",
      "#define mp make_pair",
      "",
      "#ifndef ONLINE_JUDGE",
      "#define debug(x) cerr << #x <<\" \"; _print(x); cerr << endl;",
      "#else",
      "#define debug(x)",
      "#endif",
      "",
      "void _print(ll w) {cerr << w;}",
      "void _print(int w) {cerr << w;}",
      "void _print(string w) {cerr << w;}",
      "void _print(char w) {cerr << w;}",
      "void _print(lld w) {cerr << w;}",
      "void _print(double w) {cerr << w;}",
      "void _print(ull w) {cerr << w;}",
      "",
      "template <class T, class V> void _print(pair <T, V> p);",
      "template <class T> void _print(vector <T> v);",
      "template <class T> void _print(set <T> v);",
      "template <class T, class V> void _print(map <T, V> v);",
      "template <class T> void _print(multiset <T> v);",
      "template <class T, class V> void _print(pair <T, V> p) {cerr << \"{\"; _print(p.ff); cerr << \",\"; _print(p.ss); cerr << \"}\";}",
      "template <class T> void _print(vector <T> v) {cerr << \"[ \"; for (T i : v) {_print(i); cerr << \" \";} cerr << \"]\";}",
      "template <class T> void _print(set <T> v) {cerr << \"[ \"; for (T i : v) {_print(i); cerr << \" \";} cerr << \"]\";}",
      "template <class T> void _print(multiset <T> v) {cerr << \"[ \"; for (T i : v) {_print(i); cerr << \" \";} cerr << \"]\";}",
      "template <class T, class V> void _print(map <T, V> v) {cerr << \"[ \"; for (auto i : v) {_print(i); cerr << \" \";} cerr << \"]\";}",
      "",
      "const int MAX_N = 1e5 + 1;",
      "const ll MOD = 1e9 + 7;",
      "const ll INF = 1e9;",
      "",
      "int n,m;",
      "vi v[100001];",
      "",
      "/*",
      "//	DFS IMPLEMENTATION IN ADJACENCY LIST",
      "int visited[100001];",
      "void dfs(int node) {",
      "    visited[node]=1;",
      "",
      "    for(int child : v[node]){",
      "        if(!visited[child]){",
      "            dfs(child);",
      "        }",
      "    }",
      "}",
      "*/",
      "",
      "/*",
      "//	DFS IMPLEMENTATION IN 2D ARRAY",
      "int visited[10001][10001];",
      "bool isVaild(int x,int y){",
      "    return (x>=0 && x<n && y>=0 && y<m && !visited[x][y] ); // Maybe some other conditions too",
      "}",
      "",
      "void dfs(int x,int y){",
      "    visited[x][y]=1;",
      "    ",
      "    if(isVaild(x,y-1))	//top",
      "        dfs(x,y-1);",
      "    if(isValid(x+1,y))	//right",
      "        dfs(x+1,y);",
      "    if(isValid(x,y+1))	//down",
      "        dfs(x,y+1);",
      "    if(isValid(x-1,y))	//left",
      "        dfs(x-1,y);",
      "}",
      "*/",
      "",
      "void makeGraph(){",
      "\t$2 ",
      "}",
      "",
      "int main() {",
      "    ios_base::sync_with_stdio(0);",
      "    cin.tie(0); cout.tie(0);",
      "    #ifndef ONLINE_JUDGE",
      "      freopen(\"input.txt\",\"r\",stdin);",
      "      freopen(\"output.txt\",\"w\",stdout);",
      "      freopen(\"error.txt\", \"w\", stderr);",
      "    #endif",
      "    int tc = 1;",
      "    //$1cin >> tc;",
      "    f1(t,tc) {",
      "        // cout << \"Case #\" << t  << \": \";",
      "        f1(i,n){",
      "            v[i].clear();",
      "            //visited[i]=0;",
      "            //f0(j,m)   visited[i][j]=0;",
      "        }",
      "        makeGraph();",
      "        //dfs(_node_);",
      "    }",
      "}"
    ],
    "description": "My Graph-DFS CP Template"
  },
  "Basic Segment Tree": {
    "prefix": "segment_tree",
    "body": [
      "struct ST {",
      "	vll segtree, v;",
      "	void init (ll n) {",
      "		ll size = 1;",
      "		while(size < n) {",
      "			size *= 2;",
      "		}",
      "		size++;",
      "		v.assign(size, 0);",
      "		segtree.assign(2 * size, 0);",
      "	}",
      "	void buildTree(ll si, ll ss, ll se) {",
      "		if(ss == se) {",
      "			segtree[si] = v[ss];",
      "			return;",
      "		}",
      "		ll mid = ss + (se - ss) / 2;",
      "		buildTree(2 * si, ss, mid);",
      "		buildTree(2 * si + 1, mid + 1, se);",
      "		segtree[si] = segtree[2 * si] + segtree[2 * si + 1];",
      "	}",
      "	ll query(ll si, ll ss, ll se, ll qs, ll qe) {",
      "		// COMPLETELY OUTSIDE",
      "		if(ss > qe || se < qs) {",
      "			return 0;",
      "		}",
      "		// COMPLETELY INSIDE",
      "		if(ss >= qs && se <= qe) {",
      "			return segtree[si];",
      "		}",
      "",
      "		ll mid = ss + (se - ss) / 2;",
      "		ll left = query(2 * si, ss, mid, qs, qe);",
      "		ll right = query(2 * si + 1, mid + 1, se, qs, qe);",
      "		return (left + right);",
      "	}",
      "	void update(ll si, ll ss, ll se, ll qi) {",
      "		if(ss == se) {",
      "			segtree[si] = v[ss];",
      "			return;",
      "		}",
      "		ll mid = ss + (se - ss) / 2;",
      "		if(qi <= mid) {",
      "			update(2 * si, ss, mid, qi);",
      "		} else {",
      "			update(2 * si + 1, mid + 1, se, qi);",
      "		}",
      "		segtree[si] = segtree[2 * si] + segtree[2 * si + 1];",
      "	}",
      "};",
      ""
    ],
    "description": "Basic Segment Tree"
  },
  "Segment Tree + Range Tree": {
    "prefix": "segment_range_tree",
    "body": [
      "struct ST {",
      "	vll segtree, v, rangetree;",
      "	",
      "	void init (ll n) {",
      "		ll size = 1;",
      "		while(size < n) {",
      "			size *= 2;",
      "		}",
      "		size++;",
      "		v.assign(size, 0);",
      "		segtree.assign(2 * size, 0);",
      "		rangetree.assign(2 * size, 0);",
      "	}",
      "",
      "	void buildTree(ll si, ll ss, ll se) {",
      "		if(ss == se) {",
      "			segtree[si] = v[ss];",
      "			return;",
      "		}",
      "		ll mid = ss + (se - ss) / 2;",
      "		buildTree(2 * si, ss, mid);",
      "		buildTree(2 * si + 1, mid + 1, se);",
      "		segtree[si] = segtree[2 * si] + segtree[2 * si + 1];",
      "	}",
      "",
      "	ll query(ll si, ll ss, ll se, ll qs, ll qe) {",
      "		// COMPLETELY OUTSIDE",
      "		if(ss > qe || se < qs) {",
      "			return 0;",
      "		}",
      "		// COMPLETELY INSIDE",
      "		if(ss >= qs && se <= qe) {",
      "			return segtree[si];",
      "		}",
      "",
      "		ll mid = ss + (se - ss) / 2;",
      "		ll left = query(2 * si, ss, mid, qs, qe);",
      "		ll right = query(2 * si + 1, mid + 1, se, qs, qe);",
      "		return (left + right);",
      "	}",
      "",
      "	void update(ll si, ll ss, ll se, ll qi) {",
      "		if(ss == se) {",
      "			segtree[si] = v[ss];",
      "			return;",
      "		}",
      "		ll mid = ss + (se - ss) / 2;",
      "		if(qi <= mid) {",
      "			update(2 * si, ss, mid, qi);",
      "		} else {",
      "			update(2 * si + 1, mid + 1, se, qi);",
      "		}",
      "		segtree[si] = segtree[2 * si] + segtree[2 * si + 1];",
      "	}",
      "",
      "	// for range queries",
      "	void rangeUpdate(ll si, ll ss, ll se, ll qs, ll qe, ll val) {",
      "		// COMPLETELY OUTSIDE",
      "		if(ss > qe || se < qs) {",
      "			return;",
      "		}",
      "		// COMPLETELY INSIDE",
      "		if(ss >= qs && se <= qe) {",
      "			rangetree[si] += val;",
      "			return;",
      "		}",
      "",
      "		ll mid = ss + (se - ss) / 2;",
      "		rangeUpdate(2 * si, ss, mid, qs, qe, val);",
      "		rangeUpdate(2 * si + 1, mid + 1, se, qs, qe, val);",
      "	}",
      "",
      "	// get modified value of segment tree at position pos",
      "	ll getValue (ll si, ll ss, ll se, ll pos) {",
      "		if(ss == se) {",
      "			return rangetree[si];",
      "		}",
      "		ll mid = ss + (se - ss) / 2;",
      "		ll ans;",
      "		if(pos <= mid) {",
      "			ans = getValue(2 * si, ss, mid, pos);",
      "		} else {",
      "			ans = getValue(2 * si + 1, mid + 1, se, pos);",
      "		}",
      "		return rangetree[si] + ans;",
      "	}",
      "};",
      ""
    ],
    "description": "Segment Tree + Range Tree"
  },
  "Segment Tree - Operation on Range": {
    "prefix": "range_tree",
    "body": [
      "struct RT {",
      "	// any value which is never achieved",
      "	ll NO_OPERATION = INF;",
      "	vll operations;",
      "",
      "	void init (ll n) {",
      "		ll size = 1;",
      "		while(size < n) {",
      "			size *= 2;",
      "		}",
      "		size++;",
      "		operations.assign(2 * size, 0);",
      "	}",
      "",
      "	// some operations on every ele in [l, r]",
      "	ll operation(ll a, ll b) {",
      "		if(b == NO_OPERATION)",
      "			return a;",
      "		return b;",
      "	}",
      "",
      "	void apply_operation(ll &a, ll b) {",
      "		a = operation(a, b);",
      "	}",
      "",
      "	void propogation(ll si, ll ss, ll se) {",
      "		if(ss == se) {",
      "			return;",
      "		}",
      "		// prapogate from node to children",
      "		apply_operation(operations[2 * si], operations[si]);",
      "		apply_operation(operations[2 * si + 1], operations[si]);",
      "		operations[si] = NO_OPERATION;",
      "	}",
      "",
      "	void rangeUpdate(ll si, ll ss, ll se, ll qs, ll qe, ll val) {",
      "		// debug(mp(si, mp(ss, se)));",
      "		propogation(si, ss, se);",
      "		// COMPLETELY OUTSIDE",
      "		if(ss > qe || se < qs) {",
      "			return;",
      "		}",
      "		// COMPLETELY INSIDE",
      "		if(ss >= qs && se <= qe) {",
      "			apply_operation(operations[si], val);",
      "			return;",
      "		}",
      "",
      "		ll mid = ss + (se - ss) / 2;",
      "		rangeUpdate(2 * si, ss, mid, qs, qe, val);",
      "		rangeUpdate(2 * si + 1, mid + 1, se, qs, qe, val);",
      "	}",
      "",
      "	ll getValue(ll si, ll ss, ll se, ll pos) {",
      "		// debug(mp(si, mp(ss, se)));",
      "		propogation(si, ss, se);",
      "		if(ss == se)",
      "			return operations[si];",
      "		ll mid = ss + (se - ss) / 2;",
      "		ll ans;",
      "		if(pos <= mid) {",
      "			ans = getValue(2 * si, ss, mid, pos);",
      "		} else {",
      "			ans = getValue(2 * si + 1, mid + 1, se, pos);",
      "		}",
      "		return ans;",
      "	}",
      "};",
      ""
    ],
    "description": "Segment Tree - Operation on Range"
  },
  "power with mod": {
    "prefix": "power",
    "body": [
      "ll pow(ll x, ll y, ll m){",
      "    ll ans = 1;",
      "    ll r = 1;",
      "    while(r<=y){",
      "        if(r&y){",
      "            ans = (1LL*ans*x)%m;",
      "        }",
      "        x = (1LL*x*x)%m;",
      "        r = r<<1;",
      "    }",
      "    return ans;",
      "}",
      ""
    ],
    "description": "power with mod"
  },
  "inverse modulo": {
    "prefix": "modInverse",
    "body": ["ll modInv(ll n, ll m){", "    return pow(n, m-2, m);", "}", ""],
    "description": "inverse modulo"
  },
  "SeiveOfEratosthenes - prime upto x": {
    "prefix": "seive",
    "body": [
      "vll findPrime(ll x) {",
      "	vb isPrime(x+1, true);",
      "	vll primes;",
      "	isPrime[0] = false;",
      "	isPrime[1] = false;",
      "	for(int i = 2; i<=x; i++){",
      "		if(isPrime[i]){",
      "			for(int j=i*2; j<=x; j+=i){",
      "				isPrime[j] = false;",
      "			}",
      "		}",
      "	}",
      "	f1(i, x) if (isPrime[i]) primes.pb(i);",
      "	return primes;",
      "}",
      "",
      ""
    ],
    "description": "SeiveOfEratosthenes - prime upto x"
  },
  "seive - linear": {
    "prefix": "seive_linear",
    "body": [
      "vector<int> least = {0, 1};",
      "vector<int> primes;",
      "int precalculated = 1;",
      "void RunLinearSieve(int n) {",
      "  n = max(n, 1);",
      "  least.assign(n + 1, 0);",
      "  primes.clear();",
      "  for (int i = 2; i <= n; i++) {",
      "    if (least[i] == 0) {",
      "      least[i] = i;",
      "      primes.push_back(i);",
      "    }",
      "    for (int x : primes) {",
      "      if (x > least[i] || i * x > n) {",
      "        break;",
      "      }",
      "      least[i * x] = x;",
      "    }",
      "  }",
      "  precalculated = n;",
      "}"
    ],
    "description": "seive - linear"
  },
  "check if number is prime": {
    "prefix": "checkPrime",
    "body": [
      "bool isPrime(ll n){",
      "	if (n == 1 || n % 2 == 0) {",
      "		return false;",
      "	}",
      "	for (ll i = 3; i * i <= n; i += 2) {",
      "		if(n % i==0){",
      "            return false;",
      "        }",
      "	}",
      "	return true;",
      "}",
      ""
    ],
    "description": "check if number is prime"
  },
  "primeFactors of X": {
    "prefix": "findFactors",
    "body": [
      "vpll findFactors(ll x) {",
      "    vpll pf;",
      "	ll c = 0;",
      "	while (x % 2 == 0){",
      "		x /= 2;",
      "		c++;",
      "	}",
      "	if(c>0)	pf.pb(mp(2, c));",
      "	for (ll i = 3; i * i <= x; i += 2) {",
      "		c = 0;",
      "		while (x % i == 0) {",
      "			x /= i;",
      "			c++;",
      "		}",
      "		if (c > 0)",
      "			pf.pb(mp(i, c));",
      "	}",
      "	if (x > 1) {",
      "		pf.pb(mp(x, 1));",
      "		x = 1;",
      "	}",
      "	return pf;",
      "}",
      ""
    ],
    "description": "primeFactors of X"
  },
  "primeFactors - multiple queries": {
    "prefix": "findFactorsMultipleQueries",
    "body": [
      "vll gsf(MAX_N + 5);",
      "void computeGSF(){",
      "    gsf[1] = 1;",
      "	for (ll i = 2; i <= MAX_N; i++) {",
      "		if(i%2==0 && i>2)",
      "            gsf[i] = 2;",
      "        else",
      "            gsf[i] = i;",
      "	}",
      "	for (ll i = 3; i * i <= MAX_N; i++) {",
      "		if(gsf[i] == i){",
      "			for (ll j = i * i; j <= MAX_N; j += i) {",
      "				if (gsf[j] == j)",
      "					gsf[j] = i;",
      "			}",
      "		}",
      "	}",
      "}",
      "",
      "vll getFactotization(ll x){",
      "	vll ans;",
      "	while (x != 1) {",
      "		ans.push_back(gsf[x]);",
      "		x /= gsf[x];",
      "	}",
      "	return ans;",
      "}",
      "",
      "// store the prime factors of x in pf",
      "// computeGSF()",
      "// vll pf = getFactotization(x);",
      ""
    ],
    "description": "primeFactors - multiple queries"
  },
  "dfs-adjacencyList": {
    "prefix": "graph_dfs_AdjacencyList",
    "body": [
      "int n,m;",
      "vi graph[MAX_N];",
      "vi visited(MAX_N, 0);",
      "//	DFS IMPLEMENTATION IN ADJACENCY LIST",
      "void dfs(int node) {",
      "	visited[node]=1;",
      "	for(int child : graph[node]){",
      "		if(!visited[child]){",
      "			dfs(child);",
      "		}",
      "	}",
      "}",
      ""
    ],
    "description": "dfs-adjacencyList"
  },
  "dfs-adjacencyMatrix": {
    "prefix": "graph_dfs_AdjacencyMatrix",
    "body": [
      "int n,m;",
      "vi graph[MAX_N];",
      "int visited[MAX_N][MAX_N];",
      "//	DFS IMPLEMENTATION IN 2D ARRAY",
      "bool isValid(int x,int y){",
      "	return (x>=0 && x<n && y>=0 && y<m && !visited[x][y] ); // Maybe some other conditions too",
      "}",
      "",
      "void dfs(int x,int y){",
      "	visited[x][y]=1;",
      "	if(isValid(x,y-1))	//top",
      "		dfs(x,y-1);",
      "	if(isValid(x+1,y))	//right",
      "		dfs(x+1,y);",
      "	if(isValid(x,y+1))	//down",
      "		dfs(x,y+1);",
      "	if(isValid(x-1,y))	//left",
      "		dfs(x-1,y);",
      "}",
      ""
    ],
    "description": "dfs-adjacencyMatrix"
  },
  "Bipartite Graph": {
    "prefix": "graph_bipartite",
    "body": [
      "int n,m;",
      "vi graph[MAX_N];",
      "vi visited(MAX_N, 0);",
      "vi color(MAX_N);",
      "//	return true -> if Bipartite",
      "//	return false -> if Not Bipartite",
      "bool dfs(int node, int col) {",
      "	visited[node]=1;",
      "	color[node] = col;",
      "	for(int child : graph[node]){",
      "		if(!visited[child]){",
      "			if(!dfs(child, col^1))",
      "				return false;",
      "		}else{",
      "			if(col == color[child])",
      "				return false;",
      "		}",
      "	}",
      "	return true;",
      "}",
      ""
    ],
    "description": "Bipartite Graph"
  },
  "Cycle Detection Graph": {
    "prefix": "graph_cycleDetection",
    "body": [
      "int n,m;",
      "vi graph[MAX_N];",
      "vi visited(MAX_N, 0);",
      "//	return true -> if Cyclic",
      "//	return false -> if Not Cyclic",
      "bool dfs(int node, int par) {",
      "	visited[node]=1;",
      "	for(int child : graph[node]){",
      "		if(!visited[child]){",
      "			if(dfs(child, node))",
      "				return true;",
      "		} else {",
      "			if(child != par)",
      "				return true;",
      "		}",
      "	}",
      "	return false;",
      "}",
      ""
    ],
    "description": "Cycle Detection Graph"
  },
  "Cycle Detection Directed Graph": {
    "prefix": "graph_CycleDetection_directed",
    "body": [
      "int n,m;",
      "vi graph[MAX_N];",
      "vi visited(MAX_N, 0);",
      "vb recStack(MAX_N, false);",
      "//	return true -> if Cyclic",
      "//	return false -> if Not Cyclic",
      "bool dfs(int node) {",
      "	visited[node] = true;",
      "	recStack[node] = true;",
      "	for(int child : graph[node]) {",
      "		if(!visited[child]) {",
      "			if(dfs(child))",
      "				return true;",
      "		} else {",
      "			if(recStack[child])",
      "				return true;",
      "		}",
      "	}",
      "	recStack[node] = false;",
      "	return false;",
      "}",
      ""
    ],
    "description": "Cycle Detection Directed Graph"
  },
  "Graph In Out Time": {
    "prefix": "graph_inOutTime",
    "body": [
      "int n,m;",
      "vi graph[MAX_N];",
      "vi visited(MAX_N, 0);",
      "vi in(MAX_N, 0);",
      "vi out(MAX_N, 0);",
      "int timer = 0;",
      "//	In Time -> time when we enter a node",
      "//	Out Time -> time when we exit a node",
      "void dfs(int node) {",
      "	visited[node]=1;",
      "	in[node] = timer++;",
      "	for(int child : graph[node]){",
      "		if(!visited[child]){",
      "			dfs(child);",
      "		}",
      "	}",
      "	out[node] = timer++;",
      "}",
      ""
    ],
    "description": "Graph In Out Time"
  },
  "Graph Subtree Size": {
    "prefix": "graph_subtreeSize",
    "body": [
      "int n,m;",
      "vi graph[MAX_N];",
      "vi visited(MAX_N, 0);",
      "vi subtree_size(MAX_N, 0);",
      "//	Size of subtree including the node itself",
      "int dfs(int node) {",
      "	visited[node]=1;",
      "    int curr_size = 1;",
      "    for(int child : graph[node]){",
      "		if(!visited[child]){",
      "			curr_size += dfs(child);",
      "		}",
      "	}",
      "	subtree_size[node] = curr_size;",
      "	return curr_size;",
      "}",
      ""
    ],
    "description": "Graph Subtree Size"
  },
  "Graph BFS": {
    "prefix": "graph_bfs_AdjacencyList",
    "body": [
      "int n,m;",
      "vi graph[MAX_N];",
      "vi visited(MAX_N, 0);",
      "vi dist(MAX_N, 0);",
      "void bfs(int src) {",
      "	queue<int> q;",
      "	q.push(src);",
      "	visited[src] = 1;",
      "	dist[src] = 0;",
      "	while(!q.empty()) {",
      "		int node = q.front();",
      "		q.pop();",
      "		for(int child : graph[node]) {",
      "			if(!visited[child]) {",
      "				q.push(child);",
      "				dist[child] = dist[node] + 1;",
      "				visited[child] = 1;",
      "			}",
      "		}",
      "	}",
      "}",
      ""
    ],
    "description": "Graph BFS"
  },
  "Graph - Articulation Point": {
    "prefix": "graph_articulationPoint",
    "body": [
      "int n,m;",
      "vi graph[MAX_N];",
      "vi visited(MAX_N, 0);",
      "vi in(MAX_N, 0);",
      "vi low(MAX_N, 0);",
      "int timer;",
      "",
      "void dfs(int node, int par) {",
      "	visited[node]=1;",
      "	in[node] = low[node] = timer++;",
      "	int children = 1;",
      "	for(int child : graph[node]){",
      "		if(!visited[child]){",
      "			dfs(child, node);",
      "			children++;",
      "			low[node] = min(low[node], low[child]);",
      "			if(par != -1 && low[node] >= in[child])",
      "				cout << node << \" is cut vertex\" << endl;",
      "		} else {",
      "			if(child == par)",
      "				continue;",
      "			low[node] = min(low[node], in[child]);",
      "		}",
      "	}",
      "	if(par == -1 && children > 1) {",
      "		cout << node << \" is cut vertex\" << endl;",
      "	}",
      "}",
      ""
    ],
    "description": "Graph - Articulation Point"
  }
}
